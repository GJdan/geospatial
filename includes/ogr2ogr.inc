<?php
/**
 * @file cedar_gi.ogr2ogr.inc an abstraction layer for cedar_gi's ogr2ogr functionality
 *
 * @todo Restore bulk API compatibility.  It was lost when adding the ability to process multi layered zips.
 */

class ogr2ogr {
  private $tmpdir;
  private $type;
  private $pointer;
  public $csv;

  function __construct($uri) {
    // Get ogr2ogr bin
    $this->ogr2ogr_bin = geospatial_get_ogr2ogr_path();

    // Create tmp directory
    $tmpdir = tempnam(sys_get_temp_dir(), 'mapshape');
    unlink($tmpdir);
    mkdir($tmpdir);
    $this->tmpdir = $tmpdir;
    $this->uri = $uri;

    $this->ogr2ogr_files = array();  // Zip files may contain multiple kmls or shps.
    $this->current_file_index = 0;
  }

  private function extract() {
    $zippath = drupal_realpath($this->uri);
    $zip = new ArchiverZip($zippath);
    $zip->extract($this->tmpdir);
  }

  private function find_files($type) {
    return file_scan_directory($this->tmpdir, '/^.*\.(' . $type . ')$/')
  }

  function prepare() {
    $urlinfo = parse_url($this->uri);
    $fileinfo = pathinfo($urlinfo['path']);
    $extension = $fileinfo['extension'];

    if (in_array($extension, array('zip', 'shpz'))) {
      $this->extract();
      $shapefiles = $this->find_files('shp');

      foreach ($shapefiles as $shp) {
        $this->run_ogr2ogr($shp->uri);
      }
    } elseif ($extension == 'kmz') {
      $this->extract();
      $kml_files = $this->find_files('kml');

      foreach ($kml_files as $kml) {
        $this->run_ogr2ogr($kml->uri);
      }
    } elseif ($extension == 'kml') {
      $this->run_ogr2ogr(drupal_realpath($this->uri));
    }
  }

  /**
   * Convert a spatial file into a CSV with WKT Geometries, and store it in the ogr2ogr_files property for later.
   */
  private function run_ogr2ogr($uri) {
    // Figure out what the csv will be called.
    $csv_name = 'shape' . count($this->ogr2ogr_files) . '.csv';

    // Convert shapefile into a csv file
    $command = $this->ogr2ogr_bin . " -f csv -t_srs 'EPSG:4326' -lco GEOMETRY=AS_WKT " . $this->tmpdir . '/ogr2ogr/' . $csv_name . ' ' . $uri;
    system(escapeshellcmd($command));

    array_push($this->ogr2ogr_files, $this->tmpdir . '/ogr2ogr/' . $csv_name);
  }

  private function open() {
    if (file_exists($this->ogr2ogr_files[$this->current_file_index]) && $this->csv = fopen($this->ogr2ogr_files[$this->current_file_index], 'r')) {
      return TRUE;
    } else {
      return FALSE;
    }
  }

  /**
   * This method may be used to reopen the current file and seek to the previous location when continuing
   * the processing over multiple page loads.
   */
  function reopen() {
    $was_opened = $this->open();
    fseek($this->csv, $this->pointer);

    return $was_opened;
  }

  function fgetcsv() {
    $data = fgetcsv($this->csv);
    $this->pointer = ftell($this->csv);

    if ($data) {
      return $data;  // In most cases this is as far as we'll get.

    } else {  // $data returned false.. Attempt to open the next file in the list and return the first line.
      $next_file = $this->open(++$this->current_file_index);

      if ($next_file) {
      // Let's automatically skip the headers.
      fgetcsv($this->csv);

      // Then return the first line in the next csv.
      $data = fgetcsv($this->csv);
      $this->pointer = ftell($this->csv);
      return $data;

      } else {
        // There was no next file to open...
        return FALSE;
      }
    }
  }

  /**
   * We use this close() method instead of __destruct() because this class is designed to be able
   * to persist through multiple page loads so as to be usable with the bulk API.  As such we do not
   * want to delete the files generated by this instance until we know we are finished.  At that point
   * we might as well close the CSV generated by ogr2ogr at the same time as cleaning generated files.
   */
  function close() {
    @fclose($this->csv);

    // Remove all files created by this instance.
    file_unmanaged_delete_recursive($this->tmpdir);
  }
}
